
#include <iostream>
#include <time.h>
#include <string>
#include <fstream>
#include <memory> 
#include <vector>
using namespace std;
//---------------------Функции и Прототипы---------------------------------------





//------------------------MAIN----------------------------------------------------
int main() {
 setlocale(LC_ALL, "RU");
 srand(time(NULL));
 //-------------------------------САМА ПРОГА-------------------------------------

/* -----------------------РАЗЪЯСНЯЮЩИЙ ПРИМЕР-----------------------------------------
 int arr[] = { 2,6,9 };

 // способы обратиться к элементу массива

 cout << arr[1] << endl;             // обычный оператор []
  
 cout << *(arr + 1) << endl;         // арифметика указателей

 */ //------------------------------------------------------------------------------------


 vector<int> myVector = { 1,9,44,422,676,78 };

 //cout << myVector[1] << endl;                 // стандартное обращение через []

 vector<int>::iterator it;                      // объявление ИТЕРАТОРА

 it = myVector.begin();                         // begin() возвращает ИТЕРАТОР ( такого типа
                                                // как нам требуется ).

                           //наш итератор "указывает на первый элемент нашего массива"
                           //мы можем получить доступ через наш итератор к 1 элементу вектора

 //*it = 1000;             // РАЗИМЕНОВАВ итератор , мы можем менять ДАННЫЕ на которые он "указ"
 
 //it += 2;                // "арифметика итератора", фактически так мы можем "смещать" 
                           // итератор в нужную нам сторону ( на нужный элемент )
 //it--;

 // cout << *it << endl;   // Что бы получить ДАННЫЕ , на которые "указывает" итератор , 
                           // его необходимо "разименовать"




 //метод end() - указывает на элемент ПОСЛЕ ПОСЛЕДНЕГО. Например , если в векторе 10 элементов
 // то метод end() укажет на несуществующий 11. ( помним , что в векторе память выделяется послед.)

 for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
 {
  cout << *i << endl;
 }

 cout << endl;
 // РЕВЕРС ( начинается с конца вектора , заканчивается на начале )

 for (vector<int>::reverse_iterator i = myVector.rbegin(); i != myVector.rend(); i++)
 {
  cout << *i << endl;
 }

 cout << endl << endl << endl;


 //-----------------------------------------------------------------------------
 cout << *(it + 3) << endl; // смещение итератора через "арифметику итераторов" 
 
 advance(it, 3);    // увеличит значение ИТЕРАТОРА на 3 , необходимо , если наш тип данных
                    // не поддерживает "арифметику итераторов"
 
 
 cout << *it << endl << endl << endl;
 //-------------------------------------------------------------------------------

 for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
 {
  cout << *i << endl;
 }

 cout << " insert " << endl << endl;

 vector<int>::iterator it2 = myVector.begin();

 advance(it2, 5);

 myVector.insert(it2, 999);                    // добавление элемента по указанному итератору

  for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
  {
   cout << *i << endl;
  }

  cout << " erase " << endl << endl;

  vector<int>::iterator itErase = myVector.begin();

  //itErase++;

  //myVector.erase(itErase);                // удаляет элемент из вектора по указанному итер.

  myVector.erase(itErase, itErase + 3);     // перегрузка оператора erase , можно удалить
                                            // диапозон элементов

  for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
  {
   cout << *i << endl;
  }
 /*
 //Если мы хотим , что бы данные в итераторе НЕЛЬЗЯ было изменить , то можно использовать
 // КОНСТАНТНЫЙ итератор ( так же можно использовать КОНСТАНТНЫЙ cbegin() )

 for (vector<int>::const_iterator i = myVector.cbegin(); i != myVector.cend(); i++)
 {
  // *i = 10;    // в этом случае , при попытке сменить данные, будет ошибка
  cout << *i << endl;
 }
 */

 return 0;
}
